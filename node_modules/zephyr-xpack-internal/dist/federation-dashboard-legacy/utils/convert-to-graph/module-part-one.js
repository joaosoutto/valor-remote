"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.modulePartOne = modulePartOne;
const node_path_1 = require("node:path");
const node_fs_1 = require("node:fs");
const get_licenses_1 = require("./get-licenses");
function isString(value) {
    return typeof value === 'string';
}
/**
 * TODO: needs full rewrite Module analyzes the build statistics from Rspack to identify
 * three key aspects of Module Federation. It calculate remote-module, container entry and
 * node_modules
 *
 * 1. Remote Modules (remote-module) // TODO: this is broken needs to fix Tracks which
 *    modules are being consumed from other federated applications Maps the relationships
 *    between consuming applications and their remote dependencies Records where these
 *    remote modules are being used within the application
 * 2. Container Entry (container entry) Processes the entry points exposed by the Module
 *    Federation container Creates a mapping of exposed modules and their file locations
 * 3. Node Modules (node_modules) Collects information about third-party dependencies Gathers
 *    metadata like package versions, licenses, and sizes Helps track shared dependencies
 *    between federated applications
 *
 * @param modules - The stats object from @rspack/core to parse.
 * @returns An object containing the consumes, modulesObj, and npmModules.
 */
function modulePartOne(modules) {
    const consumes = [];
    const consumesByName = {};
    const modulesObj = {};
    const npmModules = new Map();
    modules?.forEach((mod) => {
        const { identifier, reasons, moduleType, nameForCondition, size } = mod;
        const data = identifier?.split(' ');
        if (moduleType === 'remote-module') {
            if (data?.length === 4 && isString(data[3]) && isString(data[2])) {
                const name = data[3].replace('./', '');
                let applicationID = data[2].replace('webpack/container/reference/', '');
                if (applicationID.includes('?')) {
                    applicationID = new URLSearchParams(applicationID.split('?')[1]).get('remoteName');
                }
                const consume = {
                    consumingApplicationID: name,
                    applicationID,
                    name,
                    usedIn: new Set(),
                };
                consumes.push(consume);
                if (nameForCondition) {
                    consumesByName[nameForCondition] = consume;
                }
            }
            if (reasons) {
                reasons.forEach(({ userRequest, resolvedModule }) => {
                    if (!userRequest || !consumesByName[userRequest] || !resolvedModule)
                        return;
                    const module = resolvedModule.replace('./', '');
                    consumesByName[userRequest].usedIn.add(module);
                });
            }
        }
        else if (data && data[0] === 'container' && data[1] === 'entry' && data[3]) {
            JSON.parse(data[3]).forEach(([prefixedName, file]) => {
                const name = prefixedName.replace('./', '');
                modulesObj[file.import[0]] = {
                    id: `${name}:${name}`,
                    name,
                    applicationID: name,
                    requires: [],
                    file: file.import[0],
                };
            });
        }
        else if (nameForCondition && nameForCondition.includes('node_modules')) {
            const contextArray = nameForCondition.split(node_path_1.sep);
            const afterModule = nameForCondition.split('node_modules' + node_path_1.sep);
            const search = afterModule[1] && afterModule[1].startsWith('@') ? 3 : 2;
            contextArray.splice(contextArray.indexOf('node_modules') + search);
            const context = contextArray.join(node_path_1.sep);
            const packageJsonFile = (0, node_path_1.join)(context, 'package.json');
            const packageJson = safe_read_package_json_sync(packageJsonFile);
            if (packageJson) {
                const existingPackage = npmModules.get(packageJson.name);
                if (existingPackage) {
                    const existingReference = existingPackage[packageJson.version];
                    const data = {
                        name: packageJson.name,
                        version: packageJson.version,
                        homepage: packageJson.homepage,
                        license: (0, get_licenses_1.getLicenses)(packageJson),
                        size: (Number(existingReference.size) || 0) + (size ?? 0),
                    };
                    if (existingReference) {
                        Object.assign(existingReference, data);
                    }
                    else {
                        existingPackage[packageJson.version] = data;
                    }
                    npmModules.set(packageJson.name, existingPackage);
                }
                else {
                    const newDep = {
                        [packageJson.version]: {
                            name: packageJson.name,
                            version: packageJson.version,
                            homepage: packageJson.homepage,
                            license: (0, get_licenses_1.getLicenses)(packageJson),
                            size,
                        },
                    };
                    npmModules.set(packageJson.name, newDep);
                }
            }
        }
    });
    return { consumes, modulesObj, npmModules };
}
function safe_read_package_json_sync(file_path) {
    try {
        return JSON.parse((0, node_fs_1.readFileSync)(file_path, { encoding: 'utf-8' }));
    }
    catch {
        return;
    }
}
//# sourceMappingURL=module-part-one.js.map