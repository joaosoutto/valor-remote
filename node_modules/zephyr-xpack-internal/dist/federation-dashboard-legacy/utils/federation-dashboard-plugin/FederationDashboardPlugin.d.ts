import { ConvertedGraph, ZeUploadBuildStats } from 'zephyr-edge-contract';
import { ZephyrEngine } from 'zephyr-agent';
import { TopLevelPackage } from '../convert-to-graph/validate-params';
import { FederationDashboardPluginOptions } from './federation-dashboard-plugin-options';
import { Exposes } from './federation-dashboard-types';
import { XChunk, XCompiler, XStats, XStatsChunk, XStatsCompilation, ModuleFederationPlugin } from '../../../xpack.types';
interface ProcessWebpackGraphParams {
    stats: XStats;
    stats_json: XStatsCompilation;
    pluginOptions: {
        zephyr_engine: ZephyrEngine;
        mfConfig: ModuleFederationPlugin[] | ModuleFederationPlugin | undefined;
        target?: 'ios' | 'android' | 'web' | undefined;
    };
}
export declare class FederationDashboardPlugin {
    _options: FederationDashboardPluginOptions;
    _dashData: string | undefined;
    allArgumentsUsed: [file: string, applicationID: string, name: string][];
    FederationPluginOptions: {
        name?: string;
        remotes?: unknown;
        /**
         * **bundle_name**: This is a placeholder option since Repack is fast iterating on
         * Module Federation, right now they are consuming JS bundle and ignore
         * mf-manifest.json, but if it comes back this field will be needed to understand what
         * bundle name to look for in mf-manifest.json, Available in
         * ApplicationVersion.metadata.
         */
        bundle_name?: string;
        filename?: string;
        exposes?: Exposes;
    };
    constructor(options: Partial<FederationDashboardPluginOptions>);
    /** @param {Compiler} compiler */
    apply(compiler: XCompiler): void;
    processWebpackGraph({ stats, stats_json, pluginOptions, }: ProcessWebpackGraphParams): ConvertedGraph | undefined;
    getRemoteEntryChunk(stats: XStatsCompilation, FederationPluginOptions: typeof this.FederationPluginOptions): XStatsChunk | undefined;
    /**
     * TODO: needs a full rewrite because `_group` no longer exists in both Rspack and
     * Webpack
     *
     * Return { "main": [{...dep1Details}, {...dep2Details}], "vendor": [{...dep3Details}],
     *
     * 1. Useful for dynamic imports - object generated could inform the bundler or runtime
     *    loader about which chunks are needed for specific part of the app, enabling better
     *    performance optimization 1.1 if a chunk representing a React component dynamically
     *    loads, this dependency graph can help the runtime understand what other chunks
     *    need to be loaded alongside it.
     * 2. Optimized loading and caching: By mapping chunk dependencies, this function supports
     *    advanced optimizations like caching. Chunks that havenâ€™t changed between builds
     *    can be cached separately, reducing the need for users to download unchanged code.
     *
     * }
     */
    getChunkDependencies(validChunkArray: XChunk[]): Record<string, never>;
    buildVendorFederationMap(liveStats: XStats): TopLevelPackage;
    mapToObjectRec(m: Record<string, XChunk[keyof XChunk]> | Map<string, XChunk[keyof XChunk]> | XChunk[keyof XChunk][]): Record<string, unknown>;
    /**
     * In a remote application, this function is used to find all the chunks that are
     * referenced by the remote entry chunk It won't return anything from HostApp
     */
    buildValidChunkArray(liveStats: XStats, FederationPluginOptions: typeof this.FederationPluginOptions): XChunk[];
    /**
     * We are doing this because the filename in React Native is the actual JS bundle, "How
     * we understand the filename is different in react native" - filename would be at the
     * end of the URL modified in get_mf_config.ts If we don't attach the remote bundle name
     * to metadata, we will have no track record of the actual bundle when we need it later
     * -- this is RePack specific.
     */
    attach_remote_bundle_name_to_metadata(): Record<string, string> | undefined;
    postDashboardData(): Promise<{
        value: ZeUploadBuildStats;
    } | undefined>;
}
export {};
