"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkAuth = checkAuth;
exports.isTokenStillValid = isTokenStillValid;
exports.authenticateUser = authenticateUser;
const tslib_1 = require("tslib");
const jose = tslib_1.__importStar(require("jose"));
const readline = tslib_1.__importStar(require("node:readline"));
const zephyr_edge_contract_1 = require("zephyr-edge-contract");
const errors_1 = require("../errors");
const ze_http_request_1 = require("../http/ze-http-request");
const logging_1 = require("../logging");
const picocolor_1 = require("../logging/picocolor");
const ze_log_event_1 = require("../logging/ze-log-event");
const secret_token_1 = require("../node-persist/secret-token");
const storage_keys_1 = require("../node-persist/storage-keys");
const token_1 = require("../node-persist/token");
const auth_flags_1 = require("./auth-flags");
const websocket_1 = require("./websocket");
/**
 * Check if the user is already authenticated. If not, ask if they want to open a browser
 * to authenticate. Display a message to the console.
 *
 * @returns The token as a string.
 */
async function checkAuth() {
    const secret_token = (0, secret_token_1.getSecretToken)();
    if (secret_token) {
        (0, ze_log_event_1.logFn)('debug', 'Token found in environment. Using secret token for authentication.');
        return secret_token;
    }
    const existingToken = await (0, token_1.getToken)();
    if (existingToken) {
        // Check if the token has a valid expiration date.
        if (isTokenStillValid(existingToken, auth_flags_1.TOKEN_EXPIRY.SHORT_VALIDITY_CHECK_SEC)) {
            (0, logging_1.ze_log)('You are already logged in');
            return existingToken;
        }
        await (0, token_1.removeToken)();
    }
    // In non-TTY environments it's expected that a ZE_SECRET_TOKEN is present
    // since user cannot interact with it.
    if (!picocolor_1.isTTY) {
        (0, ze_log_event_1.logFn)('warn', `Could not load ${storage_keys_1.StorageKeys.ze_secret_token}.`);
    }
    // No valid token found; initiate authentication.
    (0, ze_log_event_1.logFn)('', `${(0, picocolor_1.yellow)('Authentication required')} - You need to log in to Zephyr Cloud`);
    // Get authentication URL first
    const sessionKey = generateSessionKey();
    const authUrl = await getAuthenticationURL(sessionKey);
    const browserController = new AbortController();
    // Tries to open the browser to authenticate the user
    void promptForAuthAction(authUrl, browserController.signal)
        .then(() => openUrl(authUrl))
        .catch(() => fallbackManualLogin(authUrl));
    const newToken = await waitForAccessToken(sessionKey).finally(() => browserController.abort());
    await (0, token_1.saveToken)(newToken);
    (0, ze_log_event_1.logFn)('', `${(0, picocolor_1.green)('✓')} You are now logged in to Zephyr Cloud\n`);
    return newToken;
}
/**
 * Decides whether the token is still valid based on its expiration time.
 *
 * @param token The token to check.
 * @param gap In seconds
 * @returns Boolean indicating if the token is still valid.
 */
function isTokenStillValid(token, gap = 0) {
    // Attempts to decode the token
    try {
        const decodedToken = jose.decodeJwt(token);
        if (decodedToken.exp) {
            return new Date(decodedToken.exp * 1000) > new Date(Date.now() + gap * 1000);
        }
        // No expiration date found, invalid token.
        return false;
    }
    catch (_a) {
        // If the token is invalid, return false.
        return false;
    }
}
/** Prompts the user to choose an authentication action */
async function promptForAuthAction(authUrl, signal) {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        signal,
    });
    return new Promise((resolve) => {
        rl.question((0, ze_log_event_1.formatLogMsg)(`
${authUrl}

${(0, picocolor_1.gray)(`You can hit ${(0, picocolor_1.bold)((0, picocolor_1.white)('Enter'))} to open it up on your browser.`)}
`), { signal }, resolve);
    });
}
/** Helper to display manual login instructions with highlighted URL */
function fallbackManualLogin(url) {
    (0, ze_log_event_1.logFn)('', '');
    (0, ze_log_event_1.logFn)('', `An unexpected error happened when opening the browser.`);
    (0, ze_log_event_1.logFn)('', `${(0, picocolor_1.yellow)('Please open this URL in your browser to log in:')}`);
    (0, ze_log_event_1.logFn)('', url);
    (0, ze_log_event_1.logFn)('', `${(0, picocolor_1.blue)('⏳')} Waiting for you to complete authentication in browser...`);
}
/** Opens the given URL in the default browser. */
async function openUrl(url) {
    // Lazy loads `open` module
    const openModule = (await eval(`import('open')`));
    await openModule.default(url);
}
/** Generates a URL-safe random string to use as a session key. */
function generateSessionKey() {
    return encodeURIComponent(Math.random().toString(36).substring(2, 15) +
        Math.random().toString(36).substring(2, 15));
}
/** Generates the URL to authenticate the user. */
async function getAuthenticationURL(state) {
    const [ok, cause, data] = await ze_http_request_1.ZeHttpRequest.from({
        path: zephyr_edge_contract_1.ze_api_gateway.auth_link,
        base: (0, zephyr_edge_contract_1.ZE_API_ENDPOINT)(),
        query: { state },
    });
    if (!ok) {
        throw new errors_1.ZephyrError(errors_1.ZeErrors.ERR_AUTH_ERROR, {
            cause,
            message: 'Could not get authentication URL',
        });
    }
    return data;
}
/**
 * Initiates user authentication and handles token storage.
 *
 * @returns The new token as a string.
 */
async function authenticateUser() {
    return await checkAuth();
}
/** Waits for the access token to be received from the websocket. */
async function waitForAccessToken(sessionKey) {
    const { promise, resolve, reject } = (0, zephyr_edge_contract_1.PromiseWithResolvers)();
    const socket = (0, websocket_1.createSocket)((0, zephyr_edge_contract_1.ZEPHYR_API_ENDPOINT)());
    let timeoutHandle = null;
    // Helper to properly cleanup socket
    const cleanupSocket = () => {
        if (timeoutHandle) {
            clearTimeout(timeoutHandle);
            timeoutHandle = null;
        }
        socket.removeAllListeners();
        socket.disconnect();
        socket.close();
    };
    try {
        socket.once('access-token', (token) => {
            cleanupSocket();
            resolve(token);
        });
        // Creating errors outside of the listener closure makes the stack trace point
        // to waitForAccessToken fn instead of socket.io internals event emitter code.
        socket.once('access-token-error', (cause) => {
            cleanupSocket();
            reject(new errors_1.ZephyrError(errors_1.ZeErrors.ERR_AUTH_ERROR, {
                cause,
                message: 'Error getting access token',
            }));
        });
        socket.once('connect_error', (cause) => {
            cleanupSocket();
            reject(new errors_1.ZephyrError(errors_1.ZeErrors.ERR_AUTH_ERROR, {
                message: 'Could not connect to socket.',
                cause,
            }));
        });
        socket.emit('joinAccessTokenRoom', { state: sessionKey });
        // The user has a specified amount of time to log in through the browser.
        timeoutHandle = setTimeout(() => {
            cleanupSocket();
            reject(new errors_1.ZephyrError(errors_1.ZeErrors.ERR_AUTH_ERROR, {
                message: `Authentication timed out. Couldn't receive access token in ${auth_flags_1.DEFAULT_AUTH_COMPLETION_TIMEOUT_MS / 1000} seconds. Please try again.`,
            }));
        }, auth_flags_1.DEFAULT_AUTH_COMPLETION_TIMEOUT_MS);
        return await promise;
    }
    catch (error) {
        cleanupSocket();
        throw error;
    }
    finally {
        cleanupSocket();
    }
}
//# sourceMappingURL=login.js.map